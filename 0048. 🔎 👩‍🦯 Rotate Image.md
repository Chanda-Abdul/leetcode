## 🔎 👩‍🦯 48. Rotate Image
https://leetcode.com/problems/rotate-image/

You are given an `n x n 2D` matrix representing an image, rotate the image by <b>90</b> degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. <b>DO NOT</b> allocate another 2D matrix and do the rotation.
## Example 1:
![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)
````js
Input:

matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]

Output:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
````
## Example 2:
![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)
````js
Input:
matrix = [
  [5,1,9,11],
  [2,4,8,10],
  [13,3,6,7],
  [15,14,12,16]
]

Output:
[
  [15,13,2,5],
  [14,3,4,1],
  [12,6,8,9],
  [16,7,10,11]
]
````

## Constraints:

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

## Solution ➡️ Approach 2: Reverse on Diagonal and then Reverse Left to Right
### Intuition

The most elegant solution for rotating the matrix is to firstly reverse the matrix around the main diagonal, and then reverse it from left to right. These operations are called transpose and reflect in linear algebra.

Even though this approach does twice as many reads and writes as approach 1, most people would consider it a better approach because the code is simpler, and it is built with standard matrix operations that can be found in any matrix library.
````js
function rotateImgClockwise(matrix) {
  // 1. transpose the matrix (reverse diagonally from the top left to the bottom right)
  for (let row = 0; row < matrix.length; row++) {
    // The outer loop iterates through the rows (x).
    for (let col = row; col < matrix.length; col++) {
      // The inner loop iterates through the columns (y),
      // but only from the current row index (x) onwards to avoid swapping elements twice.

      // swaps the element at (x, y) with the element at (y, x), effectively transposing the matrix.
      [matrix[row][col], matrix[col][row]] = [
        matrix[col][row],
        matrix[row][col],
      ];
    }
  }

  // 2. reverse each row(left to right)
  for (let row = 0; row < matrix.length; row++) {
    // The outer loop iterates through the rows (x).
    for (let col = 0; col < matrix.length / 2; col++) {
      // The inner loop iterates through the first half of the columns (y < size(matrix.length) / 2).

      // swaps the element at the beginning of the row (y)
      // with the corresponding element at the end of the row (size - y - 1).
      [matrix[row][col], matrix[row][matrix.length - col - 1]] = [
        matrix[row][matrix.length - col - 1],
        matrix[row][col],
      ];
    }
  }
  console.log(matrix);
}

rotateImgClockwise([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
rotateImgClockwise([
  [5, 1, 9, 11],
  [2, 4, 8, 10],
  [13, 3, 6, 7],
  [15, 14, 12, 16],
]);

````
## Solution (Counter clockwise)

```js
function rotateImgCounterClockwise(matrix) {
  // 1. transpose the matrix (reverse diagonally from the top left to the bottom right)
  for (let row = 0; row < matrix.length; row++) {
    // The outer loop iterates through the rows (x).
    for (let col = row; col < matrix.length; col++) {
      // The inner loop iterates through the columns (y),
      // but only from the current row index (x) onwards to avoid swapping elements twice.

      // swaps the element at (x, y) with the element at (y, x), effectively transposing the matrix.
      [matrix[row][col], matrix[col][row]] = [
        matrix[col][row],
        matrix[row][col],
      ];
    }
  }

  // 2. reverse each COLUMN(TOP to BOTTOM)
  for (let row = 0; row < matrix.length; row++) {
    // The outer loop iterates through the rows (x).
    for (let col = 0; col < matrix.length / 2; col++) {
      // The inner loop iterates through the first half of the columns (y < size(matrix.length) / 2).

      // Reverse each column: Instead of reversing each row, we now reverse each column.
      // This is done by swapping elements from the top of the column (col)
      // with the corresponding elements at the bottom of the column (size - col - 1).
      [matrix[col][row], matrix[matrix.length - col - 1][row]] = [
        matrix[matrix.length - col - 1][row],
        matrix[col][row],
      ];
    }
  }
  console.log(matrix);
}

rotateImgCounterClockwise([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
```

## Time & Space Complexity
Let `M` be the number of cells in the grid.

- Time complexity is `O(M)`. We perform two steps; transposing the matrix, and then reversing each row. Transposing the matrix has a cost of `O(M)` because we're moving the value of each cell once. Reversing each row also has a cost of `O(M)`, because again we're moving the value of each cell once.
- Space complexity `O(1)` because we do not use any other additional data structures.


###### #Google #TwoPointer #Blind75 #Greedy
