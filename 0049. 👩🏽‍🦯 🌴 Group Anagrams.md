# [49. 👩🏽‍🦯🌴 Group Anagrams](https://leetcode.com/problems/group-anagrams/)

- [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) - The `Array.from()` static method creates a new, shallow-copied Array instance from an iterable or array-like object.
- [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values) - The `Object.values()` static method returns an array of a given object's own enumerable string-keyed property values.
#
> Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.

An <b>Anagram</b> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

## Example 1:
````
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
````
## Example 2:
````
Input: strs = [""]
Output: [[""]]
````
## Example 3:
````
Input: strs = ["a"]
Output: [["a"]]
````
## Constraints:
- `1 <= strs.length <= 10^4`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.

## Solution 
````js
function groupAnagrams(strs) {
  // Base case: If the input array has 0 or 1 string,
  // there are no anagrams to group
  if (strs.length <= 1) return [strs];

  // create map to keep track of valid anagrams
  // The keys of this map will be the sorted versions of the strings
  // the values will be arrays of the original strings that are anagrams of each other.
  let groupsAndMaps = new Map();

  // iterate through each string in the input array.
  for (let i = 0; i < strs.length; i++) {
    
    //for each string strs[i]
    // split into an array of individual characters
    // sorted alphabetically
    // joined back together into a string.
    // This creates a "signature" for the anagram group.
    // All anagrams of a word will have the same signature after sorting.
    let word = strs[i].split('').sort().join('');

    // check if the groupsAndMaps has an entry
    // with the sorted word (word) as the key
    if (groupsAndMaps.has(word)) {
      
      // retrieves the existing array of anagrams from the map
      // It creates a new array (idx) by copying the existing array and adding the current string (strs[i]) to it.
      let idx = [...groupsAndMaps.get(word), strs[i]];
      
      // updates the map entry with the new array.
      groupsAndMaps.set(word, idx);
    }
    else {
      // creates a new entry in the map with the
      // sorted word as the key and
      // an array containing the current string as the value.
      groupsAndMaps.set(word, [strs[i]]);
    }
  }

  // extract all the values from the groupsAndMaps
  // and converts them into a single array using
  // This array of arrays is returned as the result.
  return Array.from(groupsAndMaps.values());

}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']);
//[["bat"],["nat","tan"],["ate","eat","tea"]]

groupAnagrams(['']);
//[[""]]

groupAnagrams(['a']);
//[["a"]]
````
## Complexity Analysis

- The <b>time complexity</b> of the above algorithm is `O(n*klog(k))` where `n` is the length of input array and `k` is the maximum length of a string in the input array
- The <b>space complexity</b> of the above algorithm will be `O(N)`

###### #Blind75 #Amazon #HashMap #Sorting
