# 198.üîé üßô‚Äç‚ôÄÔ∏è House Robber

https://leetcode.com/problems/house-robber/

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night.</b>

Given an integer array `nums` representing the amount of money of each house, return the <i>maximum amount of money you can rob tonight</i> <b>without alerting the police</b>.
## Example 1:
````
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
````
## Example 2:
````
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.

```` 

## Constraints:
- `1 <= nums.length <= 10`

## Solution 
````js
function rob(nums) {
  //At index [i], you only need to know the maximum profit at [i - 1] and [i - 2]. 
  //This is a slight variation on fibonacci.
  //Bottom up strategy
  //Iterative
  //Memoization

  //edge cases
  if (!nums.length) return 0;
  if (nums.length === 1) return nums[0];
  if (nums.length === 2) return Math.max(nums[0], nums[1]);

  //houses cannot be nextdoor, we have two options
  //1. start by robbing the house at index 0
  //OR
  //2. start by robbing the house at index 1
  let maxProfitTwoHousesDown = nums[0];
  let maxProfitOneHouseDown = Math.max(nums[0], nums[1]);

  for (let i = 2; i < nums.length; i++) {
    //You have two options here
    //1. Start by robbing the house at index 0
      //AND rob the house at index 0 + 2
      //because you cannot rob the house immediately
      //next door at index 1
    	//OR	
    //2. Just rob the house at index 1
    const maxAtCurrentHouse = Math.max(
      nums[i] + maxProfitTwoHousesDown,
      maxProfitOneHouseDown
    );

    //As we increment and visit additional houses
    // one house down becomes two houses down
    // and one house down becomes current
    //then we continue our loop until we have checked all houses on the street

    maxProfitTwoHousesDown = maxProfitOneHouseDown;
    maxProfitOneHouseDown = maxAtCurrentHouse;
  }

  //return the maxProfitOneHouseDown because we set it
  //to the max of the most recent previous 2 houses visited in our loop
  return maxProfitOneHouseDown;
}

rob([1, 2, 3, 1]);
//4
//Rob house 1 (money = 1) and then rob house 3 (money = 3).
//Total amount you can rob = 1 + 3 = 4.

rob([2, 7, 9, 3, 1]);
///12
//Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
//Total amount you can rob = 2 + 9 + 1 = 12.
````

## Time & Space Complexity
- Time complexity is `O(N)`  and Space-complexity is `O(1)`
###### #DynamicProgramming #Google #BottomUp #Iterative #Memoization #Fibonacci
