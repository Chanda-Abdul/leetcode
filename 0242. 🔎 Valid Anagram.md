# 242. ðŸ”Ž Valid Anagram 
https://leetcode.com/problems/valid-anagram/

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

An <b>Anagram</b> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

## Example 1:
````
Input: s = "anagram", t = "nagaram"
Output: true
````
## Example 2:
````
Input: s = "rat", t = "car"
Output: false
```` 

## Constraints:

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` and `t` consist of lowercase English letters.

## Sorting Solution 
An anagram is produced by rearranging the letters of `s` into `t`. Therefore, if `t` is an anagram of `s`, sorting both strings will result in two identical strings. Furthermore, if `s` and `t` have different lengths, `t` must not be an anagram of `s` and we can return early.
````
function isAnagram(s, t) {
  //edge cases
  if (s.length !== t.length) return false;
  s = s.split('').sort().join('');
  t = t.split('').sort().join('');

  return s === t;
}

isAnagram('anagram', 'nagaram'); //true
isAnagram('rat', 'car'); //false
````
### Time & Space Complexity
Time complexity  of `O(n log n)`. Assume that `n` is the length of `s`, sorting costs `O(n log n)` and comparing two strings costs `O(n)`. Sorting time dominates and the overall time complexity is `O(n log n)`.

Space complexity is `O(1)`. Space depends on the sorting implementation which, usually, costs `O(1)` auxiliary space if heapsort is used. 

## Follow up
- [X] What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to more than 1 million. A hash table is a more generic solution and could adapt to any range of characters.
## Hashmap Solution
To examine if tt is a rearrangement of `s`, we can count occurrences of each letter in the two strings and compare them. Since both `s` and `t` contain only letters from `a-z`, a simple counter table of size 26 is suffice.

Do we need two counter tables for comparison? Actually no, because we could increment the counter for each letter in `s` and decrement the counter for each letter in `t`, then check if the counter reaches back to zero.
````
function isAnagram(s, t) {
  let sMap = new Map();

  for (let i = 0; i < s.length; i++) {
    sMap.set(s[i], sMap.get(s[i]) + 1 || 1);
  }

  for (let j = 0; j < t.length; j++) {
    if (sMap.has(t[j])) {
      sMap.set(t[j], sMap.get(t[j]) - 1 || 0);
      if (sMap.get(t[j]) === 0) {
        sMap.delete(t[j]);
      }
    } else {
      sMap.set(t[j], sMap.get(t[j]) + 1 || 1);
    }
  }
  return sMap.size === 0;
}

isAnagram('anagram', 'nagaram'); //true
isAnagram('rat', 'car'); //false
````
### Time & Space Complexity
- Time complexity is `O(n)` because accessing the counter table is a constant time operation.
- Although we do use extra space, the space complexity is `O(1)` because the table's size stays constant no matter how large `n` is.

###### #Google #Sorting #Hashmap
