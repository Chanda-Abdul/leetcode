# [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

Given two strings `s1` and `s2`, return `true` if `s2` contains the permutation of `s1`.

In other words, one of `s1`'s permutations is the substring of `s2`.

 

## Example 1:
````
Input:
 s1 = "ab"
 s2 = "eidbaooo"

Output:
 true

Explanation:
 s2 contains one permutation of s1 ("ba").
````
## Example 2:
````
Input:
 s1 = "ab"
 s2 = "eidboaoo"

Output:
 false
```` 

## Constraints:

- `1 <= s1.length, s2.length <= 10^4`
- `s1` and `s2` consist of lowercase English letters.

## Solution
```js
function checkInclusion(s1, s2) {
  // considerations
    // permutation must contain s1 only
    // how to handle duplicates

  // 1. create hashmap data structure
  // to store elements of s1
  let charMap = new Map();

  for (let char of s1) {
    charMap.set(char, (charMap.get(char) || 0) + 1);
  }

  // 2. sliding window to check for permutations
  let windowStart = 0;

  // track of how many characters from s1 have been matched
  // with the correct frequency in the current window.
  let matches = 0;

  for (let windowEnd = 0; windowEnd < s2.length; windowEnd++) {
    // check each element in s1/charMap
    // for matches with each substring of s2
    const endChar = s2[windowEnd];

    // if there is a match,
    // update charMap and increment matches
    if (charMap.has(endChar)) {
      charMap.set(endChar, charMap.get(endChar) - 1);
      if (charMap.get(endChar) === 0) {
        matches++;
      }
    }

    // found a permutation
    if (matches === charMap.size) {
      return true;
    }

    // shrink window when exceeds s1.length
    // and adjust the matches and charMap accordingly
    if (windowEnd >= s1.length - 1) {
      const startChar = s2[windowStart];

      // update charMap by removing startChar if necessary
      if (charMap.has(startChar)) {
        if (charMap.get(startChar) === 0) {
          //decrement matches
          matches--;
        }
        // then add startChar back to the map
        charMap.set(startChar, charMap.get(startChar) + 1);
      }
      //continue checking
      windowStart++;
    }
  }
  return false;
}
checkInclusion('adc', "dcda");
// Output: true
checkInclusion('ab', 'eidbaooo');
// Output: true
checkInclusion('ab', 'eidboaoo');
// Output: false
checkInclusion('abc', 'lecabee');
// Output: true
checkInclusion('abc', 'lecaabee');
// Output: false
```

## Time & Space Complexity
- The above algorithm’s time complexity will be `O(N + M)`, where `‘N’` and `‘M’` are the number of characters in the input string and the pattern, respectively.
- The algorithm’s space complexity is `O(M)` since, in the worst case, the whole pattern can have distinct characters that will go into the HashMap.

###### #SlidingWindow #HashMap
