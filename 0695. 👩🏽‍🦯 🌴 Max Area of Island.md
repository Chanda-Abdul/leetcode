# 695. 👩🏽‍🦯 🌴 Max Area of Island
https://leetcode.com/problems/max-area-of-island/

You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value `1` in the island.

> Return the maximum area of an island in `grid`. If there is no island, return `0`.

 
## Example 1:
![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)
````js
Input :
Input: grid = [
  [0,0,1,0,0,0,0,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,1,1,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,0,1,1,0,0,1,0,1,0,0],
  [0,1,0,0,1,1,0,0,1,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6

Explanation: The answer is not 11, because the island must be connected 4-directionally.
````
## Example 2:
````js
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
````

## Constraints

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` is `'0'` or `'1'`.

## Solution
````js
function numIslands(grid) {
  let islands = 0;

  //go through each cell of the grid, and DFS to find islands
  for (let rows = 0; rows < grid.length; rows++) {
    for (let cols = 0; cols < grid[0].length; cols++) {
      if (grid[rows][cols] === '1') {
        islands++;
        dfs(rows, cols);
      }
    }
  }

  function dfs(row, col) {
    //in grid where "1", turns it into a "0"
    if (grid[row][col] === '1') {
      grid[row][col] = '0';
    } else {
      return;
    }

    //else, we should go "exploring" in DFS manner
    //any of the left, right, up, down 1's(n-ary tree)
    //return if
    //row is out of bounds(row < 0 )
    // OR col is at/out of bounds(col < 0 )

    //check up
    if (row < grid.length - 1) {
      dfs(row + 1, col);
    }
    //check down
    if (row > 0 && row < grid.length) {
      dfs(row - 1, col);
    }
    // check right
    if (col < grid[row].length - 1) {
      dfs(row, col + 1);
    }
    // check left
    if (col > 0 && col < grid[row].length) {
      dfs(row, col - 1);
    }
  }

  return islands;
}


numIslands(
  grid = [
    ['1', '1', '1', '1', '0'],
    ['1', '1', '0', '1', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '0', '0', '0'],
  ]
);
// Output: 1

numIslands(
  grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1'],
  ]
);
// Output: 3

````


## Complexity Analysis
- Time complexity of `O(M×N)` where `M` is the number of rows and `N` is the number of columns.
- Space complexity in the worst case is `O(M×N)` in case that the grid map is filled with lands where `DFS` goes by `M×N` deep.

###### #Blind75 #Google #Amazon #DepthFirstSearch #DFS #BreadthFirstSearch #BFS #NaryTree
