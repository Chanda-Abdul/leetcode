# 2096.  ðŸ”Ž Step-By-Step Directions From a Binary Tree Node to Another
https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/

You are given the root of a <b>binary tree</b> with `n` nodes. Each <i>node</i> is uniquely assigned a value from `1` to `n`. You are also given an integer `startValue` representing the value of the <i>start node</i> `s`, and a different integer `destValue` representing the value of the <i>destination node</i> `t`.

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:

'L' means to go from a node to its left child node.
'R' means to go from a node to its right child node.
'U' means to go from a node to its parent node.
Return the step-by-step directions of the shortest path from node s to node t.

 

Example 1:


Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
Output: "UURL"
Explanation: The shortest path is: 3 â†’ 1 â†’ 5 â†’ 2 â†’ 6.
Example 2:


Input: root = [2,1], startValue = 2, destValue = 1
Output: "L"
Explanation: The shortest path is: 2 â†’ 1.
 

Constraints:

The number of nodes in the tree is n.
2 <= n <= 105
1 <= Node.val <= n
All the values in the tree are unique.
1 <= startValue, destValue <= n
startValue != destValue
 
## Example 1:
![](https://assets.leetcode.com/uploads/2021/11/15/eg1.png)
````js
Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers 
since per each level it does not matter the order on which elements are returned.
````
## Example 2:
![](https://assets.leetcode.com/uploads/2021/11/15/eg2.png)
````js
Input: root = [1]
Output: [[1]]
````


## Constraints:

- The number of nodes in the tree is in the range `[1, 100]`.
- `-100 <= Node.val <= 100`

## Solution
````js
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

function findLeaves(root) {  
  //recursively traverse in DFS to remove leaf nodes
  function collectAndRemoveLeaves(currentNode, results) {
    //base case
    if (currentNode === null) return null;

    //if there is no left or right subleaf
    //we have reached the end of the current branch, push the currentNode.val onto results
    if (currentNode.left === null && currentNode.right === null) {
      results.push(currentNode.val);
      return null;
    }

    //recursively check each left and right subtree
    currentNode.left = collectAndRemoveLeaves(currentNode.left, results);
    currentNode.right = collectAndRemoveLeaves(currentNode.right, results);
    return currentNode;
  }
  let results = [];
  
  //traverse to end of branches to find leaves
  while (root !== null) {
    let currentLeaves = [];
    root = collectAndRemoveLeaves(root, currentLeaves);
    results.push(currentLeaves);
  }

  return results;
}

let root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
findLeaves(root);

root = new TreeNode(1);
findLeaves(root);
````

## Complexity Analysis
- <b>Time Complexity</b>: Assuming `N` is the total number of nodes in the <b>binary tree</b>, traversing the tree takes `O(N)` <b>time</b> and storing all the pairs at the correct position also takes `O(N)` time. Hence overall time complexity of this approach is `O(N)`.
- <b>Space Complexity</b>: `O(N)`, the space used by `results` array.



###### #Google #DFS #DepthFirstSearch #Recursive #Backtracking #BinaryTree
