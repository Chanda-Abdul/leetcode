# [2946. Matrix Similarity After Cyclic Shifts](https://leetcode.com/problems/matrix-similarity-after-cyclic-shifts/description/)

You are given an `m x n` integer `matrix` and an integer `k`. The `matrix` rows are 0-indexed.

The following proccess happens `k` times:

- **Even-indexed** rows (0, 2, 4, ...) are cyclically shifted to the left.
![](https://assets.leetcode.com/uploads/2024/05/19/lshift.jpg)


- **Odd-indexed** rows (1, 3, 5, ...) are cyclically shifted to the right.
![https://assets.leetcode.com/uploads/2024/05/19/lshift.jpg](https://assets.leetcode.com/uploads/2024/05/19/rshift-stlone.jpg)

Return `true` if the final modified `matrix` after `k` steps is identical to the original `matrix`, and `false` otherwise.

## Example 1:
> **Input:**
>
> `matrix = [[1,2,3],[4,5,6],[7,8,9]]`
> 
> `k = 4`
>
> **Output:** false
>
> **Explanation:** In each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).
> ![](https://assets.leetcode.com/uploads/2024/05/19/t1-2.jpg)
## Example 2:
> **Input:**
>
> `Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]]`
> 
> ` k = 2`
>
> **Output:** true
>
> **Explanation:**
> 
> ![](https://assets.leetcode.com/uploads/2024/05/19/t1-3.jpg)
## Example 3:
> **Input:**
>
> `matrix = [[2,2],[2,2]]`
> 
> `k = 3`
>
> **Output:** false
>
> **Explanation:** As all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.

## Constraints:
- `1 <= mat.length <= 25`
- `1 <= mat[i].length <= 25`
- `1 <= mat[i][j] <= 25`
- `1 <= k <= 50`

## Solution using Hash Table + Prefix Sum + Enumeration
````ts
function areSimilar(matrix, k) {
  const matrixLength = matrix.length;
  const rowLength = matrix[0].length;

  // Optimization:
  // If k is a multiple of rowLength
  // the matrix will be the same
  if (k % rowLength === 0) {
    return true;
  }

  // Calculate the effective shift for each row
  for (let i = 0; i < matrixLength; i++) {

    let shift = k % rowLength;

    //update odd indexed rows,
    if ((matrixLength === 1 && i === 0) || i % 2 === 1) {
      shift = rowLength - shift;
    }

    for (let j = 0; j < rowLength; j++) {
      if (matrix[i][j] !== matrix[i][(j + shift) % rowLength]) {
        // If any element doesn't match, return false
        return false;
      }
    }
  }

  return true;
}

areSimilar([[1, 2]], 1);
// Output: false

areSimilar(
  [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
  ],
  4
);
// Output: false
// Explanation:
// In each step left shift is applied to rows 0 and 2 (even indices),
// and right shift to row 1 (odd index).

areSimilar(
  [
    [1, 2, 1, 2],
    [5, 5, 5, 5],
    [6, 3, 6, 3],
  ],
  2
);
// Output: true

areSimilar(
  [
    [2, 2],
    [2, 2],
  ],
  3
);
// Output: true
// Explanation:
// As all the values are equal in the matrix,
// even after performing cyclic shifts
// the matrix will remain the same.

````

## Time & Space Complexity
- The **Time Complexity** is 
- The **Space Complexity** is 


###### #Array #Matrix #IBM
