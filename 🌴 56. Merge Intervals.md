# 56. Merge Intervals ðŸŒ´
#Arrays

https://leetcode.com/problems/merge-intervals/

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

## Example 1:

### Input: 
`intervals = [[1,3],[2,6],[8,10],[15,18]]`
### Output: 
`[[1,6],[8,10],[15,18]]`
### Explanation: 
`Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].`

## Example 2:

### Input: 
`intervals = [[1,4],[4,5]]`
### Output: 
`[[1,5]]`
### Explanation: 
`Intervals [1,4] and [4,5] are considered overlapping.` 

## Constraints:
- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

## My Solution 
````
const merge = function(intervals) {
  if(intervals.length < 2) return intervals
  //sort
  intervals.sort((a, b) => a[0] - b[0])
  for(let i = 1; i < intervals.length; i++) {
    let current = intervals[i]
    let previous = intervals[i-1]
    if(current[0] <= previous[1]) {
      intervals[i] =[previous[0], Math.max(previous[1], current[1])]
      intervals.splice(i-1, 1)
      i--
    }
  }
  
  
  return intervals
    
};

merge([[1,3],[2,6],[8,10],[15,18]])
merge([[1,4],[4,5]])
merge([[1,4]])
````

## Time Complexity
The splice function can become a little expensive as `i` approaches 0 and the array has to be spliced (worst case scenario `O(n * (n - i)`) when i is relatively small, i.e. when the splice fires a number of times around the beginning of an intervals array which is large). This kind of method works better with a Linked List since the removal of an explicitly known node is `O(1)`
## Space Complexity
The space complexity of the above algorithm will be 
